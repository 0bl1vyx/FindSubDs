#!/bin/bash

# --- Colors ---
# Using tput for compatibility and to avoid hardcoded escape sequences
RED=$(tput setaf 1)
GRN=$(tput setaf 2)
YLW=$(tput setaf 3)
BLU=$(tput setaf 4)
MAG=$(tput setaf 5)
CYN=$(tput setaf 6)
WHT=$(tput setaf 7)
BOLD=$(tput bold)
NC=$(tput sgr0) # No Color

# --- UI Functions ---
spinner_with_updates() {
    local pid=$1
    local name=$2
    local spin=('â ‹' 'â ™' 'â ¹' 'â ¸' 'â ¼' 'â ´' 'â ¦' 'â §' 'â ‡' 'â ')
    local i=0
    tput civis
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r${MAG}${spin[$i]}${NC} ${BOLD}${name}...${NC}"
        i=$(( (i + 1) % 10 ))
        sleep 0.1
    done
    printf "\r$(tput el)" # Clear the line
    tput cnorm
}

banner() {
    echo -e "${BLU}${BOLD}"
    echo '    â”Œâ”€â”â”¬ â”¬â”Œâ” â”Œâ”€â”â”Œâ”¬â”â”Œâ”€â”â”Œâ”€â”â”Œâ”€â”'
    echo '    â”œâ”€â”¤â””â”¬â”˜â”œâ”´â”â””â”€â” â”‚ â”œâ”€â”˜â”Œâ”€â”˜â”Œâ”€â”˜'
    echo '    â”´ â”´ â”´ â””â”€â”˜â””â”€â”˜ â”´ â”´  â””â”€â”˜â””â”€â”˜ v2.8' # Version bump for scope fix
    echo -e "         ${NC}${CYN}by 0bl1vyx${NC}"
}

stage() {
    echo -e "\n${BLU}${BOLD}[ ${WHT}âš™ï¸  ${BLU}] ${WHT}${1}${NC}"
}

summary() {
    local total_subs=$1
    local live_subs=$2
    local output_file=$3
    local duration=$4

    echo -e "\n${GRN}${BOLD}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${NC}"
    echo -e "${GRN}${BOLD}â”‚${NC}                 ${WHT}ğŸ‰ Scan Summary ğŸ‰${NC}                 ${GRN}${BOLD}â”‚${NC}"
    echo -e "${GRN}${BOLD}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
    echo -e "${GRN}${BOLD}â”‚${NC} ${CYN}â±ï¸  Run time:${NC}         ${WHT}${duration} seconds${NC}"
    echo -e "${GRN}${BOLD}â”‚${NC} ${CYN}ğŸ“¦ In-scope domains:${NC} ${WHT}${total_subs}${NC}"
    echo -e "${GRN}${BOLD}â”‚${NC} ${CYN}ğŸŒ Live subdomains:${NC}  ${WHT}${live_subs}${NC}"
    echo -e "${GRN}${BOLD}â”‚${NC} ${CYN}ğŸ’¾ Output files:${NC}     ${YLW}${output_file}, ${LIVEOUT}${NC}"
    echo -e "${GRN}${BOLD}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}\n"
}

usage() {
    banner
    echo -e "\n${WHT}A fast, parallel subdomain enumeration script that combines passive and active techniques.${NC}"
    echo -e "\n${BOLD}USAGE:${NC}"
    echo -e "    $0 -d <domain> -o <all_subs.txt> -l <live_subs.txt> [OPTIONS]"
    echo -e "\n${BOLD}REQUIRED ARGUMENTS:${NC}"
    echo -e "    ${YLW}-d${NC}    Target domain (e.g., example.com)"
    echo -e "    ${YLW}-o${NC}    Output file for all unique, in-scope subdomains found"
    echo -e "    ${YLW}-l${NC}    Output file for live subdomains (responding to HTTP/S)"
    echo -e "\n${BOLD}OPTIONAL ARGUMENTS:${NC}"
    echo -e "    ${YLW}-w${NC}    Path to a wordlist for subdomain brute-forcing with puredns"
    echo -e "    ${YLW}-r${NC}    Path to a file of valid DNS resolvers for puredns"
    echo -e "    ${YLW}-p${NC}    Run permutations with alterx (Very Time Consuming)"
    echo -e "    ${YLW}-v${NC}    Verbose mode. Disables spinners and shows tool output."
    echo -e "    ${YLW}-h${NC}    Display this help menu and exit"
    echo -e "\n${BOLD}EXAMPLE:${NC}"
    echo -e "    ${CYN}$0 -d example.com -o subs.txt -l live.txt -w words.txt -r resolvers.txt -v${NC}\n"
    exit 1
}


# --- Argument Parsing ---
PERMUTE_FLAG=0
VERBOSE_FLAG=0
while getopts "d:o:l:w:r:phv" opt; do
  case $opt in
    d) DOMAIN=$OPTARG ;;
    o) OUTPUT=$OPTARG ;;
    l) LIVEOUT=$OPTARG ;;
    w) WORDLIST=$OPTARG ;;
    r) RESOLVERS=$OPTARG ;;
    p) PERMUTE_FLAG=1 ;;
    v) VERBOSE_FLAG=1 ;;
    h) usage ;;
    *) usage ;;
  esac
done

# --- Prerequisite Checks ---

for tool in subfinder findomain dnsx httpx puredns alterx comm sort grep mv; do
  if ! command -v "$tool" >/dev/null 2>&1; then
    echo -e "${RED}${BOLD}[âœ˜] Tool missing: ${tool}. Please install it first.${NC}"
    exit 1
  fi
done

# Validate required arguments
if [[ -z "$DOMAIN" || -z "$OUTPUT" || -z "$LIVEOUT" ]]; then
  usage
fi

# Validate optional brute-force arguments
if [[ (-n "$WORDLIST" && -z "$RESOLVERS") || (-z "$WORDLIST" && -n "$RESOLVERS") ]]; then
    echo -e "${RED}${BOLD}[!] Both -w (wordlist) and -r (resolvers) must be provided together for brute-forcing.${NC}"
    exit 1
fi
if [[ -n "$WORDLIST" && ! -f "$WORDLIST" ]]; then
    echo -e "${RED}${BOLD}[!] Wordlist file not found: $WORDLIST${NC}"
    exit 1
fi
if [[ -n "$RESOLVERS" && ! -f "$RESOLVERS" ]]; then
    echo -e "${RED}${BOLD}[!] Resolvers file not found: $RESOLVERS${NC}"
    exit 1
fi


# Check for existing output files
if [[ -f "$OUTPUT" || -f "$LIVEOUT" ]]; then
  echo -e "${YLW}${BOLD}[!] Output file(s) already exist. Overwrite? [y/N]${NC}"
  read -r confirm
  if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
    echo -e "${RED}${BOLD}[âœ˜] Operation aborted by user.${NC}"
    exit 1
  fi
fi

# --- Main Execution ---
start_time=$SECONDS
clear
banner

echo -e "\n${WHT}${BOLD}TARGET:${NC} ${YLW}$DOMAIN${NC}"
echo -e "${WHT}${BOLD}OUTPUT:${NC} ${YLW}$OUTPUT${NC} | ${WHT}${BOLD}LIVE:${NC} ${YLW}$LIVEOUT${NC}"
MODE="Passive"
if [[ -n "$WORDLIST" ]]; then
    MODE="Passive + Brute-Force"
fi
if [[ "$PERMUTE_FLAG" -eq 1 ]]; then
    MODE="${MODE} + Permutations"
fi
if [[ "$VERBOSE_FLAG" -eq 1 ]]; then
    MODE="${MODE} + Verbose"
fi
echo -e "${WHT}${BOLD}MODE:   ${YLW}${MODE}${NC}"


# Temp files
SUBF=$(mktemp)
FINDO=$(mktemp)
BRUTE=$(mktemp)
RESOLVED=$(mktemp)
PERMUTE_OUT=$(mktemp)
ALREADY_RESOLVED=$(mktemp)
NEEDS_RESOLUTION=$(mktemp)
FILTERED_OUTPUT=$(mktemp) # <-- NEW: For final filtering

trap 'rm -f "$SUBF" "$FINDO" "$BRUTE" "$RESOLVED" "$PERMUTE_OUT" "$ALREADY_RESOLVED" "$NEEDS_RESOLUTION" "$FILTERED_OUTPUT"; tput cnorm' EXIT


# --- [BLOCK 1: Passive] ---
stage "Running passive enumeration tools in parallel"
if [[ "$VERBOSE_FLAG" -eq 1 ]]; then
    echo -e "${YLW}${BOLD}[v] VERBOSE MODE: Running tools in foreground, showing output...${NC}"
    (
        echo "[v] Starting subfinder..."
        subfinder -d "$DOMAIN" -all -o "$SUBF" &
        
        echo "[v] Starting findomain..."
        findomain -t "$DOMAIN" > "$FINDO" &
        wait
    )
    echo -e "${GRN}${BOLD}â””â”€â”€ Passive enumeration complete.${NC}"
else
    (
        subfinder -d "$DOMAIN" -all -silent -o "$SUBF" > /dev/null 2>&1 &
        findomain -t "$DOMAIN" > "$FINDO" 2>/dev/null &
        wait
    ) &
    spinner_with_updates $! "Passive Enumeration (subfinder + findomain)"
    echo -e "${GRN}${BOLD}â””â”€â”€ Done.${NC}"
fi


# --- Show passive results ---
echo -e "\n${CYN}${BOLD}   Passive Tool Results:${NC}"
declare -A passive_sources
passive_sources["$SUBF"]="Subfinder"
passive_sources["$FINDO"]="Findomain"
for file in "${!passive_sources[@]}"; do
    if [[ -s "$file" ]]; then
        count=$(wc -l < "$file" | tr -d ' ')
        printf "   ${BLU}â”œâ”€â”€ ${WHT}%-15s${NC}: %s results\n" "${passive_sources[$file]}" "$count"
    fi
done


# --- [BLOCK 2: Brute-force] ---
if [[ -n "$WORDLIST" && -n "$RESOLVERS" ]]; then
  stage "Running puredns for brute-force enumeration"
  if [[ "$VERBOSE_FLAG" -eq 1 ]]; then
      echo -e "${YLW}${BOLD}[v] VERBOSE MODE: Running puredns, showing output...${NC}"
      puredns bruteforce "$WORDLIST" "$DOMAIN" -r "$RESOLVERS" -w "$BRUTE" # No --quiet
  else
      (puredns bruteforce "$WORDLIST" "$DOMAIN" -r "$RESOLVERS" -w "$BRUTE" --quiet >/dev/null 2>&1) &
      spinner_with_updates $! "Brute-forcing"
  fi
  echo -e "${GRN}${BOLD}â””â”€â”€ Done.${NC}"
fi


# --- Show brute-force results ---
echo -e "\n${CYN}${BOLD}   Brute-Force Tool Results:${NC}"
if [[ -s "$BRUTE" ]]; then
    count=$(wc -l < "$BRUTE" | tr -d ' ')
    printf "   ${BLU}â”œâ”€â”€ ${WHT}%-15s${NC}: %s results\n" "PureDNS Brute" "$count"
fi


# --- [BLOCK 3: Merge] ---
stage "Merging initial results"
if [[ "$VERBOSE_FLAG" -eq 1 ]]; then
    echo -e "${YLW}${BOLD}[v] Merging results...${NC}"
    cat "$SUBF" "$FINDO" "$BRUTE" | sort -u > "$OUTPUT"
else
    (cat "$SUBF" "$FINDO" "$BRUTE" | sort -u > "$OUTPUT") &
    spinner_with_updates $! "Merging results"
fi
echo -e "${GRN}${BOLD}â””â”€â”€ Done.${NC}"


# --- [MODIFIED BLOCK 4: Permutations] ---
# We now filter the input to alterx to *only* include in-scope domains.
if [[ "$PERMUTE_FLAG" -eq 1 ]]; then
  stage "Running permutations with alterx"
  if [[ "$VERBOSE_FLAG" -eq 1 ]]; then
      echo -e "${YLW}${BOLD}[v] Filtering for in-scope domains to feed alterx...${NC}"
      echo -e "${YLW}${BOLD}[v] Running alterx & dnsx, showing output...${NC}"
      # --- FIX: Pipe only in-scope domains to alterx ---
      grep -iE "(\.$DOMAIN$|^$DOMAIN$)" "$OUTPUT" | alterx | dnsx | sort -u > "$PERMUTE_OUT"
  else
      # --- FIX: Pipe only in-scope domains to alterx ---
      (grep -iE "(\.$DOMAIN$|^$DOMAIN$)" "$OUTPUT" | alterx -silent | dnsx -silent | sort -u > "$PERMUTE_OUT") &
      spinner_with_updates $! "Running alterx & dnsx"
  fi
  
  perm_count=$(wc -l < "$PERMUTE_OUT" | tr -d ' ')
  echo -e "${GRN}${BOLD}â””â”€â”€ Found ${perm_count} potential permutations.${NC}"
  
  (cat "$PERMUTE_OUT" >> "$OUTPUT"; sort -u "$OUTPUT" -o "$OUTPUT") &
  spinner_with_updates $! "Merging permutation results"
  echo -e "${GRN}${BOLD}â””â”€â”€ Done.${NC}"
fi


# --- [NEW BLOCK 4.5: Final Scoping] ---
# This is the main fix. We filter the *entire* list to ensure only
# true subdomains of the target are kept before resolution.
stage "Filtering for in-scope domains"
if [[ "$VERBOSE_FLAG" -eq 1 ]]; then
    echo -e "${YLW}${BOLD}[v] Filtering all results to match target scope: $DOMAIN${NC}"
    grep -iE "(\.$DOMAIN$|^$DOMAIN$)" "$OUTPUT" | sort -u > "$FILTERED_OUTPUT"
    mv "$FILTERED_OUTPUT" "$OUTPUT"
else
    (grep -iE "(\.$DOMAIN$|^$DOMAIN$)" "$OUTPUT" | sort -u > "$FILTERED_OUTPUT" && mv "$FILTERED_OUTPUT" "$OUTPUT") &
    spinner_with_updates $! "Enforcing target scope"
fi
scope_count=$(wc -l < "$OUTPUT" | tr -d ' ')
echo -e "${GRN}${BOLD}â””â”€â”€ ${scope_count} in-scope domains identified.${NC}"


# --- [MODIFIED BLOCK 5: Smart Resolution] ---
# This block's logic is now correct because $OUTPUT is pre-filtered.
# $ALREADY_RESOLVED is also clean because $BRUTE and $PERMUTE_OUT
# were generated from scoped inputs.
stage "Optimizing resolution and checking live hosts"
if [[ "$VERBOSE_FLAG" -eq 1 ]]; then
    echo -e "${YLW}${BOLD}[v] Consolidating known-resolved...${NC}"
    cat "$BRUTE" "$PERMUTE_OUT" | sort -u > "$ALREADY_RESOLVED"
    
    echo -e "${YLW}${BOLD}[v] Finding passive domains that need resolution...${NC}"
    comm -23 <(sort "$OUTPUT") "$ALREADY_RESOLVED" > "$NEEDS_RESOLUTION"
    
    echo -e "${YLW}${BOLD}[v] Resolving remaining passive domains...${NC}"
    dnsx -l "$NEEDS_RESOLUTION" -o "$RESOLVED" # No -silent
    
    echo -e "${YLW}${BOLD}[v] Checking live hosts...${NC}"
    (cat "$RESOLVED" "$ALREADY_RESOLVED" | sort -u) | httpx -o "$LIVEOUT" # No -silent
    
    echo -e "${GRN}${BOLD}â””â”€â”€ Resolution complete.${NC}"
else
    (cat "$BRUTE" "$PERMUTE_OUT" | sort -u > "$ALREADY_RESOLVED") &
    spinner_with_updates $! "Consolidating known-resolved"

    (comm -23 <(sort "$OUTPUT") "$ALREADY_RESOLVED" > "$NEEDS_RESOLUTION") &
    spinner_with_updates $! "Finding domains that need resolution"

    (dnsx -l "$NEEDS_RESOLUTION" -silent -o "$RESOLVED" > /dev/null 2>&1) &
    spinner_with_updates $! "Resolving remaining domains"

    ( (cat "$RESOLVED" "$ALREADY_RESOLVED" | sort -u) | httpx -silent -o "$LIVEOUT" > /dev/null 2>&1 ) &
    spinner_with_updates $! "Checking live hosts"
    echo -e "${GRN}${BOLD}â””â”€â”€ Done.${NC}"
fi

# --- Summary ---
total=$(wc -l < "$OUTPUT" | tr -d ' ')
live=$(wc -l < "$LIVEOUT" | tr -d ' ')
duration=$(( SECONDS - start_time ))
summary "$total" "$live" "$OUTPUT" "$duration"
